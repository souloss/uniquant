use std::{collections::{BTreeMap, HashSet}, fs, path::Path};
use codegen::{Scope, Impl, Function};
use serde::Deserialize;
use serde_yaml;

#[derive(Debug, Deserialize)]
struct CodeEntry {
    code: i32,
    description: String,

    // 其余未显式列出的字段（例如 en、zh-CN 等）会被收集到这里
    #[serde(flatten)]
    translations: BTreeMap<String, String>,
}

#[derive(Debug, Deserialize)]
struct CodesYaml {
    success: BTreeMap<String, CodeEntry>,
    error: BTreeMap<String, CodeEntry>,
}

/// 运行代码生成：codes.yaml → app_code.rs
pub fn run(codes_path: &str, locales_dir: &str, output_file: &str) -> anyhow::Result<()> {
    let yaml_str = fs::read_to_string(codes_path)?;
    let codes: CodesYaml = serde_yaml::from_str(&yaml_str)?;

    generate_appcode(&codes, Path::new(output_file))?;

    // 2) 收集所有 language keys（从 translations 字段）
    let mut languages: HashSet<String> = HashSet::new();
    for entry in codes.success.values().chain(codes.error.values()) {
        for (k, _) in &entry.translations {
            languages.insert(k.clone());
        }
    }

    // 3) 为每个语言生成/补全对应的 ftl（例如 locales_dir/en.ftl）
    for lang in languages {
        // 规范路径：例如 locales_dir/en.ftl
        let ftl_path = Path::new(locales_dir).join(format!("{}.ftl", lang));
        generate_ftl_for_lang(&codes, &lang, &ftl_path)?;
    }

    // 另外：如果目录里已有 .ftl 而不是在 YAML 中出现的语言，也不修改（只处理 YAML 中出现的语言）
    Ok(())
}

/// 为某个语言补全 ftl（只补缺失键，不覆盖已有内容）
fn generate_ftl_for_lang(codes: &CodesYaml, lang: &str, ftl_path: &Path) -> anyhow::Result<()> {
    // 确保父目录存在
    if let Some(parent) = ftl_path.parent() {
        fs::create_dir_all(parent)?;
    }

    let mut content = String::new();

    // ------------------------------
    // 🟢 Success 部分
    // ------------------------------
    content.push_str("# --- Success ---\n");
    for (name, entry) in &codes.success {
        let key = format!("success-{}", name);
        let value = entry
            .translations
            .get(lang)
            .map(|s| s.as_str())
            .unwrap_or("");
        content.push_str(&format!(
            "## Code: {}\n{} = {}\n\n",
            entry.code,
            key,
            escape_ftl(value)
        ));
    }

    // ------------------------------
    // 🔴 Error 部分
    // ------------------------------
    content.push_str("# --- Error ---\n");
    for (name, entry) in &codes.error {
        let key = format!("error-{}", name);
        let value = entry
            .translations
            .get(lang)
            .map(|s| s.as_str())
            .unwrap_or("");
        content.push_str(&format!(
            "## Code: {}\n{} = {}\n\n",
            entry.code,
            key,
            escape_ftl(value)
        ));
    }

    // ------------------------------
    // 💾 写回文件（覆盖旧内容）
    // ------------------------------
    fs::write(ftl_path, content)?;
    println!("✅ Generated (overwrite) {} for lang: {}", ftl_path.display(), lang);

    Ok(())
}

/// 根据 YAML 定义生成 AppCode 枚举
fn generate_appcode(codes: &CodesYaml, output_file: &Path) -> anyhow::Result<()> {
    if let Some(parent) = output_file.parent() {
        fs::create_dir_all(parent)?;
    }

    let mut scope = Scope::new();
    scope.raw("//! `ftl` Code, @generated by ftl-codegen. DO NOT EDIT MANUALLY.\n\n");

    // ---------- 1️⃣ 合并 + 排序 ----------
    let mut items: Vec<(&String, &CodeEntry, &'static str)> = Vec::new();
    // success
    for (k, v) in &codes.success {
        items.push((k, v, "success"));
    }
    // error
    for (k, v) in &codes.error {
        items.push((k, v, "error"));
    }
    // 按 code 升序
    items.sort_by_key(|(_, e, _)| e.code);

    // ------------------------------
    // 1️⃣ 枚举定义
    // ------------------------------
    {
        let enum_def = scope.new_enum("AppCode");
        enum_def
            .vis("pub")
            .derive("Debug")
            .derive("Clone")
            .derive("Copy")
            .derive("PartialEq")
            .derive("Eq")
            .derive("Hash");
        enum_def.r#macro("#[repr(i32)]");

        for (name, entry, _) in &items {
            enum_def
                .new_variant(&format!("{} = {}", to_pascal_case(name), entry.code))
                .annotation(&format!("/// {}", entry.description));
        }
    }

    // ------------------------------
    // 2️⃣ impl 块
    // ------------------------------
    let mut impl_block = Impl::new("AppCode");

    // code()
    let mut code_fn = Function::new("code");
    code_fn
        .vis("pub")
        .arg_self()
        .ret("i32")
        .line("self as i32");
    impl_block.push_fn(code_fn);

    // 分类 category()
    let mut cat_fn = Function::new("category");
    cat_fn
        .vis("pub")
        .ret("&'static str")
        .arg_self()
        .line("match self {");
    for name in codes.success.keys() {
        cat_fn.line(&format!("    Self::{} => \"success\",", to_pascal_case(name)));
    }
    for name in codes.error.keys() {
        cat_fn.line(&format!("    Self::{} => \"error\",", to_pascal_case(name)));
    }
    cat_fn.line("}");
    impl_block.push_fn(cat_fn);

    // as_key()
    let mut key_fn = Function::new("as_key");
    key_fn
        .vis("pub")
        .ret("&'static str")
        .arg_self()
        .line("match self {");
    for name in codes.success.keys() {
        key_fn.line(&format!("    Self::{} => \"success-{}\",", to_pascal_case(name), name));
    }
    for name in codes.error.keys() {
        key_fn.line(&format!("    Self::{} => \"error-{}\",", to_pascal_case(name), name));
    }
    key_fn.line("}");
    impl_block.push_fn(key_fn);

    // description()
    let mut msg_fn = Function::new("description");
    msg_fn
        .vis("pub")
        .ret("&'static str")
        .arg_self()
        .line("match self {");
    for (name, entry) in &codes.success {
        msg_fn.line(&format!("    Self::{} => \"{}\",", to_pascal_case(name), entry.description));
    }
    for (name, entry) in &codes.error {
        msg_fn.line(&format!("    Self::{} => \"{}\",", to_pascal_case(name), entry.description));
    }
    msg_fn.line("}");
    impl_block.push_fn(msg_fn);

    scope.push_impl(impl_block);

    // ------------------------------
    // 3️⃣ 写文件
    // ------------------------------
    fs::write(output_file, scope.to_string())?;
    Ok(())
}

/// 将 "bad_request" → "BadRequest"
fn to_pascal_case(key: &str) -> String {
    key.split('_')
        .map(|s| {
            let mut c = s.chars();
            match c.next() {
                Some(f) => f.to_uppercase().collect::<String>() + c.as_str(),
                None => String::new(),
            }
        })
        .collect()
}

/// 将 FTL value 做必要转义（当前实现：保留原样，但对双引号做转义）
fn escape_ftl(value: &str) -> String {
    value
        .replace('=', "\\=")
}