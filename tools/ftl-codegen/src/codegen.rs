use std::{collections::HashSet, fs, path::Path};
use codegen::{Scope, Impl};
use serde::Deserialize;
use serde_yaml;
use indexmap::IndexMap;

#[derive(Debug, Deserialize)]
pub struct ArgEntry {
    #[serde(rename = "type")]
    pub arg_type: String,
    #[serde(default)]
    pub optional: bool,
}

#[derive(Debug, Deserialize)]
pub struct CodeEntry {
    pub code: i32,
    pub description: String,
    #[serde(default)]
    pub args: IndexMap<String, ArgEntry>,
    #[serde(default)]
    pub translations: IndexMap<String, String>,
    #[serde(default)]
    pub http_status: u16,
}

#[derive(Debug, Deserialize)]
pub struct CodesYaml {
    #[serde(flatten)]
    pub categories: IndexMap<String, IndexMap<String, CodeEntry>>,
}

/// å°† "bad_request" â†’ "BadRequest"
fn to_pascal_case(key: &str) -> String {
    key.split('_')
        .map(|s| {
            let mut c = s.chars();
            match c.next() {
                Some(f) => f.to_uppercase().collect::<String>() + c.as_str(),
                None => String::new(),
            }
        })
        .collect()
}

/// å°† FTL value åšå¿…è¦è½¬ä¹‰ï¼ˆå½“å‰å®ç°ï¼šä¿ç•™åŸæ ·ï¼Œä½†å¯¹åŒå¼•å·åšè½¬ä¹‰ï¼‰
fn escape_ftl(value: &str) -> String {
    value
        .replace('=', "\\=")
}

//  è¿è¡Œä»£ç ç”Ÿæˆï¼šcodes.yaml â†’ app_code.rs
pub fn run(codes_path: &str, locales_dir: &str, output_file: &str) -> anyhow::Result<()> {
    let yaml_str = fs::read_to_string(codes_path)?;
    let codes: CodesYaml = serde_yaml::from_str(&yaml_str)?;

    // æ ¹æ® codes.yaml åŠ¨æ€ç”Ÿæˆ AppError æšä¸¾
    generate_app_error(&codes, Path::new(output_file))?;

    // æ”¶é›†æ‰€æœ‰è¯­è¨€ keysï¼ˆä» translations å­—æ®µï¼‰
    let mut languages: HashSet<String> = HashSet::new();
    for top_map in codes.categories.values() {
        for entry in top_map.values() {
            for lang in entry.translations.keys() {
                languages.insert(lang.clone());
            }
        }
    }

    // ä¸ºæ¯ä¸ªè¯­è¨€ç”Ÿæˆ/è¡¥å…¨å¯¹åº”çš„ ftl
    for lang in languages {
        let ftl_path = locales_dir.to_string() + "/" + &lang + ".ftl";
        generate_ftl_for_lang(&codes, &lang, Path::new(&ftl_path))?;
    }
    Ok(())
}

fn generate_ftl_for_lang(codes: &CodesYaml, lang: &str, ftl_path: &Path) -> anyhow::Result<()> {
    // ç¡®ä¿çˆ¶ç›®å½•å­˜åœ¨
    if let Some(parent) = ftl_path.parent() {
        fs::create_dir_all(parent)?;
    }

    let mut content = String::new();

    for (_cat_name, entries) in &codes.categories {
        // åˆ†ç±»æ ‡é¢˜
        content.push_str(&format!("# --- {} ---\n", _cat_name.to_uppercase()));

        for (name, entry) in entries {
            let key = format!("{}-{}", _cat_name, name);
            let value = entry.translations.get(lang).map(|s| s.as_str()).unwrap_or("");
            content.push_str(&format!(
                "## Code: {}\n{} = {}\n\n",
                entry.code,
                key,
                escape_ftl(value)
            ));
        }
    }

    // ğŸ’¾ å†™å›æ–‡ä»¶ï¼ˆè¦†ç›–æ—§å†…å®¹ï¼‰
    fs::write(ftl_path, content)?;
    println!("âœ… Generated (overwrite) {} for lang: {}", ftl_path.display(), lang);

    Ok(())
}

/// æ ¹æ® YAML å®šä¹‰ç”Ÿæˆ AppCode æšä¸¾
fn generate_app_error(codes: &CodesYaml, output_file: &Path) -> anyhow::Result<()> {
    if let Some(parent) = output_file.parent() {
        fs::create_dir_all(parent)?;
    }

    let mut scope = Scope::new();
    scope.raw("//! `AppError` generated by ftl-codegen. DO NOT EDIT.\n\n");
    scope.raw("use std::collections::HashMap;\nuse thiserror::Error;\n\n");

    // ---------- 1ï¸âƒ£ Category æšä¸¾ ----------
    {
        let category_enum = scope.new_enum("Category");
        category_enum.vis("pub").derive("Debug").derive("Clone").derive("Copy").derive("PartialEq").derive("Eq");
        for _cat_name in codes.categories.keys() {
            category_enum.new_variant(&to_pascal_case(_cat_name));
        }
    }

    // ---------- 2ï¸âƒ£ AppError æšä¸¾ ----------
    {
        let enum_def = scope.new_enum("AppError");
        enum_def.vis("pub")
            .derive("Debug")
            .derive("Error");

        for (_cat_name, items) in &codes.categories {
            for (key, entry) in items {
                let variant_name = to_pascal_case(key);
                let variant = enum_def.new_variant(&variant_name);
                variant.annotation(&format!("#[error(\"{}\")]", entry.description));

                for (arg_name, arg_def) in &entry.args {
                    let ty = match arg_def.arg_type.as_str() {
                        "string" => "String",
                        "map" => "HashMap<String, String>",
                        "error" => "anyhow::Error",
                        _ => "String",
                    };
                    let ty = if arg_def.optional {
                        format!("Option<{}>", ty)
                    } else {
                        ty.to_string()
                    };
                    variant.named(arg_name, ty);
                }
            }
        }

    }

    // ---------------- 3ï¸âƒ£ impl AppError ----------------
    let mut impl_block = Impl::new("AppError");

    // code()
    let mut code_fn = codegen::Function::new("code");
    code_fn.vis("pub").arg_ref_self().ret("i32").line("match self {");
    for (__cat_name, items) in &codes.categories {
        for (key, entry) in items {
            code_fn.line(&format!("    Self::{} {{ .. }} => {},", to_pascal_case(key), entry.code));
        }
    }
    code_fn.line("}");
    impl_block.push_fn(code_fn);

    // category()
    let mut cat_fn = codegen::Function::new("category");
    cat_fn.vis("pub").arg_ref_self().ret("Category").line("match self {");
    for (_cat_name, items) in &codes.categories {
        for (key, _) in items {
            cat_fn.line(&format!("    Self::{} {{ .. }} => Category::{},", to_pascal_case(key), to_pascal_case(_cat_name)));
        }
    }
    cat_fn.line("}");
    impl_block.push_fn(cat_fn);

    // as_key()
    let mut key_fn = codegen::Function::new("as_key");
    key_fn.vis("pub").arg_ref_self().ret("&'static str").line("match self {");
    for (_cat_name, items) in &codes.categories {
        for (key, _) in items {
            key_fn.line(&format!("    Self::{} {{ .. }} => \"{}-{}\",", to_pascal_case(key), _cat_name, key));
        }
    }
    key_fn.line("}");
    impl_block.push_fn(key_fn);

    // description()
    let mut desc_fn = codegen::Function::new("description");
    desc_fn.vis("pub").arg_ref_self().ret("&'static str").line("match self {");
    for (_cat_name, items) in &codes.categories {
        for (key, entry) in items {
            desc_fn.line(&format!("    Self::{} {{ .. }} => \"{}\",", to_pascal_case(key), entry.description));
        }
    }
    desc_fn.line("}");
    impl_block.push_fn(desc_fn);

    // http_status()
    let mut status_fn = codegen::Function::new("http_status");
    status_fn.vis("pub").arg_ref_self().ret("u16").line("match self {");
    for (_cat_name, items) in &codes.categories {
        for (key, entry) in items {
            status_fn.line(&format!("    Self::{} {{ .. }} => {},", to_pascal_case(key), entry.http_status));
        }
    }
    status_fn.line("}");
    impl_block.push_fn(status_fn);

    // to_args()
    let mut args_fn = codegen::Function::new("to_args");
    args_fn
        .vis("pub")
        .arg_ref_self()
        .ret("HashMap<String, String>")
        .line("let mut map = HashMap::new();")
        .line("match self {");

    for (_cat_name, entries) in &codes.categories {
        for (name, entry) in entries {
            let variant_name = to_pascal_case(name);

            if entry.args.is_empty() {
                args_fn.line(&format!("    Self::{} {{ .. }} => {{}},", variant_name));
                continue;
            }

            let field_names: Vec<String> = entry.args.keys().cloned().collect();
            args_fn.line(&format!("    Self::{} {{ {} }} => {{", variant_name, field_names.join(", ")));

            for (arg_name, arg_entry) in &entry.args {
                let ty = arg_entry.arg_type.as_str();
                // æ ¹æ®ç±»å‹ç”Ÿæˆ to_string è¡¨è¾¾å¼
                let value_expr = match ty {
                    "string" | "str" => "v.to_string()",
                    "int" | "i32" | "i64" | "usize" => "v.to_string()",
                    "float" | "f32" | "f64" => "v.to_string()",
                    "bool" => "v.to_string()",
                    _ => "format!(\"{:?}\", v)",
                };

                // ç”Ÿæˆæ’å…¥é€»è¾‘
                if arg_entry.optional {
                    args_fn.line(&format!(
                        "        if let Some(v) = &{0} {{ map.insert(\"{0}\".to_string(), {1}); }}",
                        arg_name, value_expr
                    ));
                } else {
                    args_fn.line(&format!(
                        "        map.insert(\"{0}\".to_string(), {1}.to_string());",
                        arg_name, arg_name
                    ));
                }
            }

            args_fn.line("    },");
        }
    }

    args_fn.line("}");
    args_fn.line("map");
    impl_block.push_fn(args_fn);

    scope.push_impl(impl_block);


    // ------------------------------
    // 3ï¸âƒ£ å†™æ–‡ä»¶
    // ------------------------------
    fs::write(output_file, scope.to_string())?;
    Ok(())
}