use std::{collections::{BTreeMap, HashSet}, fs, path::Path};
use codegen::{Scope, Impl, Function};
use serde::Deserialize;
use serde_yaml;

#[derive(Debug, Deserialize)]
struct CodeEntry {
    code: i32,
    description: String,

    // å…¶ä½™æœªæ˜¾å¼åˆ—å‡ºçš„å­—æ®µï¼ˆä¾‹å¦‚ enã€zh-CN ç­‰ï¼‰ä¼šè¢«æ”¶é›†åˆ°è¿™é‡Œ
    #[serde(flatten)]
    translations: BTreeMap<String, String>,
}

#[derive(Debug, Deserialize)]
struct CodesYaml {
    success: BTreeMap<String, CodeEntry>,
    error: BTreeMap<String, CodeEntry>,
}

/// è¿è¡Œä»£ç ç”Ÿæˆï¼šcodes.yaml â†’ app_code.rs
pub fn run(codes_path: &str, locales_dir: &str, output_file: &str) -> anyhow::Result<()> {
    let yaml_str = fs::read_to_string(codes_path)?;
    let codes: CodesYaml = serde_yaml::from_str(&yaml_str)?;

    generate_appcode(&codes, Path::new(output_file))?;

    // 2) æ”¶é›†æ‰€æœ‰ language keysï¼ˆä» translations å­—æ®µï¼‰
    let mut languages: HashSet<String> = HashSet::new();
    for entry in codes.success.values().chain(codes.error.values()) {
        for (k, _) in &entry.translations {
            languages.insert(k.clone());
        }
    }

    // 3) ä¸ºæ¯ä¸ªè¯­è¨€ç”Ÿæˆ/è¡¥å…¨å¯¹åº”çš„ ftlï¼ˆä¾‹å¦‚ locales_dir/en.ftlï¼‰
    for lang in languages {
        // è§„èŒƒè·¯å¾„ï¼šä¾‹å¦‚ locales_dir/en.ftl
        let ftl_path = Path::new(locales_dir).join(format!("{}.ftl", lang));
        generate_ftl_for_lang(&codes, &lang, &ftl_path)?;
    }

    // å¦å¤–ï¼šå¦‚æœç›®å½•é‡Œå·²æœ‰ .ftl è€Œä¸æ˜¯åœ¨ YAML ä¸­å‡ºç°çš„è¯­è¨€ï¼Œä¹Ÿä¸ä¿®æ”¹ï¼ˆåªå¤„ç† YAML ä¸­å‡ºç°çš„è¯­è¨€ï¼‰
    Ok(())
}

/// ä¸ºæŸä¸ªè¯­è¨€è¡¥å…¨ ftlï¼ˆåªè¡¥ç¼ºå¤±é”®ï¼Œä¸è¦†ç›–å·²æœ‰å†…å®¹ï¼‰
fn generate_ftl_for_lang(codes: &CodesYaml, lang: &str, ftl_path: &Path) -> anyhow::Result<()> {
    // ç¡®ä¿çˆ¶ç›®å½•å­˜åœ¨
    if let Some(parent) = ftl_path.parent() {
        fs::create_dir_all(parent)?;
    }

    let mut content = String::new();

    // ------------------------------
    // ğŸŸ¢ Success éƒ¨åˆ†
    // ------------------------------
    content.push_str("# --- Success ---\n");
    for (name, entry) in &codes.success {
        let key = format!("success-{}", name);
        let value = entry
            .translations
            .get(lang)
            .map(|s| s.as_str())
            .unwrap_or("");
        content.push_str(&format!(
            "## Code: {}\n{} = {}\n\n",
            entry.code,
            key,
            escape_ftl(value)
        ));
    }

    // ------------------------------
    // ğŸ”´ Error éƒ¨åˆ†
    // ------------------------------
    content.push_str("# --- Error ---\n");
    for (name, entry) in &codes.error {
        let key = format!("error-{}", name);
        let value = entry
            .translations
            .get(lang)
            .map(|s| s.as_str())
            .unwrap_or("");
        content.push_str(&format!(
            "## Code: {}\n{} = {}\n\n",
            entry.code,
            key,
            escape_ftl(value)
        ));
    }

    // ------------------------------
    // ğŸ’¾ å†™å›æ–‡ä»¶ï¼ˆè¦†ç›–æ—§å†…å®¹ï¼‰
    // ------------------------------
    fs::write(ftl_path, content)?;
    println!("âœ… Generated (overwrite) {} for lang: {}", ftl_path.display(), lang);

    Ok(())
}

/// æ ¹æ® YAML å®šä¹‰ç”Ÿæˆ AppCode æšä¸¾
fn generate_appcode(codes: &CodesYaml, output_file: &Path) -> anyhow::Result<()> {
    if let Some(parent) = output_file.parent() {
        fs::create_dir_all(parent)?;
    }

    let mut scope = Scope::new();
    scope.raw("//! `ftl` Code, @generated by ftl-codegen. DO NOT EDIT MANUALLY.\n\n");

    // ---------- 1ï¸âƒ£ åˆå¹¶ + æ’åº ----------
    let mut items: Vec<(&String, &CodeEntry, &'static str)> = Vec::new();
    // success
    for (k, v) in &codes.success {
        items.push((k, v, "success"));
    }
    // error
    for (k, v) in &codes.error {
        items.push((k, v, "error"));
    }
    // æŒ‰ code å‡åº
    items.sort_by_key(|(_, e, _)| e.code);

    // ------------------------------
    // 1ï¸âƒ£ æšä¸¾å®šä¹‰
    // ------------------------------
    {
        let enum_def = scope.new_enum("AppCode");
        enum_def
            .vis("pub")
            .derive("Debug")
            .derive("Clone")
            .derive("Copy")
            .derive("PartialEq")
            .derive("Eq")
            .derive("Hash");
        enum_def.r#macro("#[repr(i32)]");

        for (name, entry, _) in &items {
            enum_def
                .new_variant(&format!("{} = {}", to_pascal_case(name), entry.code))
                .annotation(&format!("/// {}", entry.description));
        }
    }

    // ------------------------------
    // 2ï¸âƒ£ impl å—
    // ------------------------------
    let mut impl_block = Impl::new("AppCode");

    // code()
    let mut code_fn = Function::new("code");
    code_fn
        .vis("pub")
        .arg_self()
        .ret("i32")
        .line("self as i32");
    impl_block.push_fn(code_fn);

    // åˆ†ç±» category()
    let mut cat_fn = Function::new("category");
    cat_fn
        .vis("pub")
        .ret("&'static str")
        .arg_self()
        .line("match self {");
    for name in codes.success.keys() {
        cat_fn.line(&format!("    Self::{} => \"success\",", to_pascal_case(name)));
    }
    for name in codes.error.keys() {
        cat_fn.line(&format!("    Self::{} => \"error\",", to_pascal_case(name)));
    }
    cat_fn.line("}");
    impl_block.push_fn(cat_fn);

    // as_key()
    let mut key_fn = Function::new("as_key");
    key_fn
        .vis("pub")
        .ret("&'static str")
        .arg_self()
        .line("match self {");
    for name in codes.success.keys() {
        key_fn.line(&format!("    Self::{} => \"success-{}\",", to_pascal_case(name), name));
    }
    for name in codes.error.keys() {
        key_fn.line(&format!("    Self::{} => \"error-{}\",", to_pascal_case(name), name));
    }
    key_fn.line("}");
    impl_block.push_fn(key_fn);

    // description()
    let mut msg_fn = Function::new("description");
    msg_fn
        .vis("pub")
        .ret("&'static str")
        .arg_self()
        .line("match self {");
    for (name, entry) in &codes.success {
        msg_fn.line(&format!("    Self::{} => \"{}\",", to_pascal_case(name), entry.description));
    }
    for (name, entry) in &codes.error {
        msg_fn.line(&format!("    Self::{} => \"{}\",", to_pascal_case(name), entry.description));
    }
    msg_fn.line("}");
    impl_block.push_fn(msg_fn);

    scope.push_impl(impl_block);

    // ------------------------------
    // 3ï¸âƒ£ å†™æ–‡ä»¶
    // ------------------------------
    fs::write(output_file, scope.to_string())?;
    Ok(())
}

/// å°† "bad_request" â†’ "BadRequest"
fn to_pascal_case(key: &str) -> String {
    key.split('_')
        .map(|s| {
            let mut c = s.chars();
            match c.next() {
                Some(f) => f.to_uppercase().collect::<String>() + c.as_str(),
                None => String::new(),
            }
        })
        .collect()
}

/// å°† FTL value åšå¿…è¦è½¬ä¹‰ï¼ˆå½“å‰å®ç°ï¼šä¿ç•™åŸæ ·ï¼Œä½†å¯¹åŒå¼•å·åšè½¬ä¹‰ï¼‰
fn escape_ftl(value: &str) -> String {
    value
        .replace('=', "\\=")
}